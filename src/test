#!/bin/sh
# this file contains functions functions that are 100% POSIX compatible
#
# Copyright (C) 2012  BjÃ¶rn Bidar
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

appname=`basename $0`
libsh_ver=@LIBSH_VER@
LIBSH_REV=@LIBSH_REV@



# base library path for import if  $SH_LIBRARY_PATH is not set
readonly IMPORT_LIBRARY_PATH=/usr/lib:/usr/lib32:/usr/local/lib:$HOME/.local/lib 
 
shload()
#################################################################
# import sh libs that are in $IMPORT_LIBRARY_PATH and $SH_LIBRARY_PATH
# vars:
# IMPORT_LIBRARY_PATH set by  import
# SH_LIBRARY_PATH     set by user use to add a library path
#################################################################    
{
    unset __shl_error_status
    case $1 in
      /*)
	    . $1
	__shl_error_status=$?
	;;
      *)
	    old_ifs=$IFS
	    IFS=:
	    for __lib_dir in ${IMPORT_LIBRARY_PATH}:${SH_LIBRARY_PATH}; do
		old_ifs=$IFS
		if [ -e $__lib_dir/$1 ] && [ -f $__lib_dir/$1 ] ; then 
		    . ${__lib_dir}/$1
		    __shl_error_status=$?
		    break
		fi
		IFS=:
	    done
	    ;;
    esac
    unset  __lib __lib_dir
    return $__shl_error_status
}

import() 
# . file with check if already . it
{
    while [ ! $# = 0 ] ; do
	old_ifs=$IFS
	IFS=:
	for __lib in $LIBSH_IMPORTED ; do
	    IFS=$old_ifs
	    if [ "$__lib" = $1 ] ; then
		__lib_aready_imported=true
		break 
	    fi
	    IFS=:
	done 
	IFS=$old_ifs
	if [   -z $__lib_aready_imported  ] ; then
	    if shload $1 ;then
		LIBSH_IMPORTED=$LIBSH_IMPORTED:$1
	    else
		echo "error loading $1"
		return 2
	    fi
	fi
	shift
	unset __lib_aready_imported
    done  
    return 0 # return how many libs were already imported
}
#########################################################################

detectDE() 
# detect which DE is running
# taken from xdg-email script 
{
    if [ x"$KDE_FULL_SESSION" = x"true" ]; then D
	DE=kde;
    elif [ x"$GNOME_DESKTOP_SESSION_ID" != x"" ]; then 
	DE=gnome;
    elif `dbus-send --print-reply --dest=org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus.GetNameOwner string:org.gnome.SessionManager > /dev/null 2>&1` ; then 
	DE=gnome;
    elif xprop -root _DT_SAVE_MODE 2> /dev/null | grep ' = \"xfce4\"$' >/dev/null 2>&1; then 
	DE=xfce;
    else 
	DE=generic 
    fi
}


d_msg() # display msgs and get input 
#########################################################################################################################
# NOTE: needs kdialog ( or zenity ) to display graphical messages and get input in gui					#
#########################################################################################################################
# usage:														#
#  d_msg [modifer] topic msg												#
#  modifers:														#
#  ! msg is an error/faile message											#
#  i msg is an msg/input ( work's not properly in cgi and with xmessage : terminal)					#
#  f msg is an yes/no msg/test												#
#  l msg is an list of items ( nyi in cgi: terminal)									#
#    no modifer msg is an normal msg											#
#########################################################################################################################
#															#
# vars:															#
# DMSG_GUI_APP=`detectDE` (default)  	# d_msg detects wich DE is installed and uses the equal dialog for displaing	#
# DMSG_GUI_APP=generic 			# only set if dialog for DE not found						#
# DMSG_GUI_APP=gnome|xfce 		# with this you can force d_msg to use zenity					#
# DMSG_GUI_APP=kde 			# with this you can force d_msg to use kdialog					#
#															#
# DMSG_GUI                      	# if not zero use graphical dialog, else cfg gui				#
# DMSG_ICON				# icon that d_msg uses when is runned in gui mode if not set icon xorg is used 	#
#															#
#															#
# DMSG_APP 				# say DMSG to use $DMSG_APP in cli possible vara are dialog and cgi_dialog	#  
#															#
#															#   
#															#
#															#
#########################################################################################################################
{
    if [ ! $# -lt 2 ] ; then
	unset dmsg_return_status
	if [  "${DMSG_GUI}" = true ] || [ ! $DMSG_GUI = 0 ] ; then
	    if [  -z "$DMSG_GUI_APP" ] ; then
		detectDE
		DMSG_GUI_APP=$DE
	    case "$DMSG_GUI_APP" in 
		kde)  
		    which  kdialog  > /dev/null  || \
			which > /dev/null  zenity  && DMSG_GUI_APP=gnome  || DMSG_GUI_APP=generic
		    ;;
		gnome|xfce) which zenity   > /dev/null   || \
		    which  kdialog  > /dev/null  && DMSG_GUI_APP=kde || \
		    DMSG_GUI_APP=generic ;;
		*) which kdialog > /dev/null  && DMSG_GUI_APP=kde || which zenity > /dev/null && DMSG_GUI_APP=zenity \
		    || DMSG_GUI_APP=generic
		    ;; 
	    esac 
	fi
	    
	    case $DMSG_GUI_APP in 
		kde)
		    case $1 in 
		    !)  kdialog --icon ${DMSG_ICON:=xorg} --caption "${DMSG_APPNAME:=$appname}" --title "$2" --error "$3" 
			dmsg_return_status=${DMG_ERR_STAUS:=1}  
			;;
		    i) kdialog --icon ${DMSG_ICON:=xorg} --caption "${DMSG_APPNAME:=$appname}" --title "$2" --inputbox "$3" 
			dmsg_return_status=$?
			;;
		    l)  kdialog --icon ${DMSG_ICON:=xorg} --caption "${DMSG_APPNAME:=$appname}" --title "$2" --menu \
			"$3" "$4" "$5" "$6" "$7" "$8" "$9" 
			shift ; dmsg_return_status=$? ;;
		    f)  kdialog --icon ${DMSG_ICON:=xorg} --caption "${DMSG_APPNAME:=$appname}"  --title "$2" --yesno "$3" 
			dmsg_return_status=$? ;;
		    *)  kdialog --icon ${DMSG_ICON:=xorg} --caption "${DMSG_APPNAME:=$appname}"  --title "$1" --msgbox "$2" 
			dmsg_return_status=$? ;;
		    esac
		    ;;
	    xfce|gnome) #nyi impleted
		    case $1 in 
		    !) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2 - ${DMSG_APPNAME:=$appname}" --error --text="$3"
			dmsg_return_status=${DMSG_ERR_STAUS:=1}   
			;;
		    i) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2 - ${DMSG_APPNAME:=$appname}" --entry --text="$3"
			dmsg_return_status=$? 
			;;
		    l) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2  -${APPNAME:=$appname}" --column='' --text="$3"\
                        --list 
		       dmsg_return_status=$? 
		       ;;
		    f) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$2  -${APPNAME:=$appname}" --question --text="$3" 
			dmsg_return_status=$? 
			;;
		    *) zenity --window-icon=${DMSG_ICON:=xorg}  --title="$1  -${APPNAME:=$appname}" --info --text="$2" 
			dmsg_return_status=$? ;;
		esac
		;;
	 *)
		    case $1 in
		    !) xmessage -center -title "$2 - ${APPNAME:=$appname}" "err: "$3"" ;
			dmsg_return_status=${DMG_ERR_STAUS:=1} 
			;;
		    f) xmessage -center -title "$2  -${APPNAME:=$appname}" -buttons no:1,yes:0 "$3" 
			dmsg_return_status=$? 
			;;	
		    i) 
			if [ -z $buttons ] ; then
			    DMSG_XBUTTONS='not:1,set:2'
			fi
			xmessage -center -title "$appname - "$2"" -print -buttons $buttons "$3"
			dmsg_return_status=$?
			;;
		    l) xmessage -center -title "$2 - ${APPNAME:=$appname}" -print -buttons "$3","$4","$5","$6","$7","$8","$9" ; dmsg_return_status=$? ;;
		    *) xmessage -center -title "$1 - ${APPNAME:=$appname}" "$2" ; dmsg_return_status=$? ;;
		    esac
		    ;;
	    esac
	else
	      case ${DMSG_APP:-native} in
	      dialog)
		  case "$1" in 
	              !) dialog --title "$2 -${APPNAME:=$appname}" --infobox "error:$3" 0 0 ;;
		      #!) cgi_dialog ! "$3" ; dmsg_return_status=${DMG_ERR_STAUS:=1}  ;;
		      f) dialog --title "$2 - ${APPNAME:=$appname}" --yesno "$3"   0 0 
			  dmsg_return_status=$?
			  ;;
		      i) dialog --title "$2 - ${APPNAME:=$appname}" --inputbox "$3" 0 0
			  dmsg_return_status=$?		 
			  ;;
		      *) dialog --title "$1 -${APPNAME:=$appname}" --infobox "$2" 0 0  ;;
		      #*) cgi_dialog "$2" ; dmsg_return_status=$? ;;
		  esac
		  ;;
	      native)
		  case "$1" in
		      !) echo  "$3" ; dmsg_return_status=${DMG_ERR_STAUS:=1}  ;;
		      f)  echo ""$3" y|n"
			  read a 
			  if [ ! $a = y ] ; then
			      dmsg_return_status=1;
			  fi
			  ;;
		      i) 
			  echo "$3"
			  read  a 
			  if [ -z "$a" ] ; then
			      dmsg_return_status=1;
			  fi
			  ;;
		      *)  echo "$2"   ; dsmg_return_status=$? ;;
		  esac
		  ;;
	      esac
	      
	fi
    fi
    return $dmsg_return_status
}


## functions for fake_arrays ########################################################################
# fake arrays are array emulated by using : as $IFS
#
#
#####################################################################################################
# NOTE:
# unlike arrays normal arrays the index of arrays starts with 1 instead of 0
# if a fake_array function gets a 0 as index parameter all entrys in the array where selected 
#
# 	for example:
#
#		var=`read_farray fu:bar 0`
#	       +var='fu bar'
#####################################################################################################	

get_farray_lenght() { # get lenght of fake array
    if [ $# -ge 1 ] ; then 
	old_ifs=$IFS
	IFS=:
	for var in $1 ; do
	    get_farry_lenght_count=$(( $get_farry_lenght_count + 1 ))
	done
	IFS=$old_ifs
	echo  ${get_farry_lenght_count:-0}
	unset get_farry_lenght_count var
    else
	echo 0
    fi
}

read_farray() { # read fake array
    if [ $# = 2 ] ; then
	old_ifs=$IFS
	IFS=:
	for var in  $1 ; do
	    _read_farry_count=$(( $_read_farry_count + 1 ))
	    if [ $2 -eq  $_read_farry_count ] || [ $2 -eq 0 ] ; then
		if [ ! -z $var ] ; then
		    echo $var
		fi
	    fi
	done
	IFS=$old_ifs
    fi
    unset _read_farry_count  var
}

write_farray() {  # write fake array   
    if [ $# -eq 3 ] ; then
	farry_content=$( eval echo \$$1)
	if [ ! -z "$farry_content" ] ; then 
		    if [ $( get_farray_lenght "$farry_content") = $(( $2 - 1 )) ] ; then
			eval $1=$farry_content:$3
		    else
			eval $( echo $1)=$( echo $farry_content | sed "s/$(read_farray $farry_content $2 )/$3/")
		    fi
	elif [ $2 = 1 ] ; then
	    eval $1=$3
	else
	    return 1
	fi
    fi
}


test_input () { 
  DMSG_i_p=$(( $# + 1 ))
  DMSG_current_err_msg="$( read_farray "$err_input_messages" $i_p )"
  if [ -n "$DMSG_current_err_msg" ] ; then
      d_msg ! 'wrong input' "$DMSG_current_err_msg"
      if [   $# = 0   ]; then
	return 1
      else
	  return 
      fi
  fi
}
